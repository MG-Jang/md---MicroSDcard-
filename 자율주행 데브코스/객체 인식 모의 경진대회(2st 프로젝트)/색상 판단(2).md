# 색상 판단

- 원하는 색상이 화면에서 차지하고 있는 비율을 계산하여
가장 많이 분포하고 있는 색상이 화면에 있는 색상으로 판단.

```c++
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main()
{
	Mat img = imread("red.JPG");
	//Mat img = imread("yellow.JPG");
	//Mat img= imread("example2.PNG");
	Mat img_hsv , img_hsv_red;
	Mat hsv;

	cvtColor(img, img_hsv, COLOR_BGR2HSV);

	Mat yellow_mask, yellow_image;

	// Hue 범위 설정
	Scalar lower_yellow = Scalar(20, 20, 100); // yellow 범위
	Scalar upper_yellow = Scalar(32, 255, 255);

	Scalar lower_red1 = Scalar(170, 20, 100);     //red 범위1
	Scalar upper_red1 = Scalar(180, 255, 255);

	Scalar lower_red2 = Scalar(0, 20, 100);     //red 범위2
	Scalar upper_red2 = Scalar(10, 255, 255);

	// 노란색 추출
	inRange(img_hsv, lower_yellow, upper_yellow, yellow_mask);
	bitwise_and(img, img, yellow_image, yellow_mask);

	imshow("yellow_image", yellow_image);  // 노란색 이미지 출력
	imshow("yellow_mask", yellow_mask);

	Mat red_mask1, red_mask2 ,red_image , red_mask; 
	Scalar added_red;

	// 빨간색 추출
	inRange(img_hsv, lower_red1, upper_red1, red_mask1); // red 범위1 mask1 생성
	inRange(img_hsv, lower_red2, upper_red2, red_mask2); // red 범위2 mask2 생성
	addWeighted(red_mask1, 1.0, red_mask2, 1.0, 0.0 , red_mask);   // mask1 + mask2 = red_mask
	bitwise_and(img, img, red_image, red_mask); // red_mask -> RGB타입으로 출력.

	imshow("red_image", red_image); // masking된 이미지 GRB타입으로 출력
	imshow("result", red_mask); // masking
	imshow("img", img);

	
	cout << "yellow_mask" << yellow_mask.size << endl;
	cout << "yellow_mask_r" << yellow_mask.rows << endl;
	cout << "yellow_mask_c" << yellow_mask.cols << endl;
	cout << "yellow_mask_ 내용물" << yellow_mask.at<Vec3b>(10,10) << endl;
	cout << "type: " << yellow_mask.type() << endl;
	cout << "type: " << img.type() << endl;

	// 색상별 범위 추출 ===========================================================
	int yellow_sum = 0 , red_sum = 0;
	// yellow 범위 추출
	for (int row = 0; row < yellow_mask.rows; row++)
	{
		for (int col = 0; col < yellow_mask.cols; col++)
		{
			uchar b = yellow_mask.at<uchar>(row, col);  // grayscale 이라 uch
			yellow_sum += b;
		}
	}
	cout << "y_sum" << yellow_sum << endl;

	// red 범위 추출
	for (int row = 0; row < red_mask.rows; row++)
	{
		for (int col = 0; col < red_mask.cols; col++)
		{
			uchar b = red_mask.at<uchar>(row, col);
			red_sum += b;
			//printf("%d" , b);
		}
		//cout << "\n" << endl;
	}
	cout << "r_sum" << red_sum << endl;

	waitKey(0);
	return 0;
}
```