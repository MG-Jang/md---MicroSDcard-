# 신호등 신호 검출

아래 코드는 Yolo에서 신호등의 바운딩 박스를 계산한 이후에 신호등을 검출하기 전 전체 이미지에서 모든 원에 해당되는 원을 검출 가능한가를 판단하는 코드다.


<br>

> 참고사항
- JPG , PNG 확장자 차이는 성능차이에 거의 없다.
- 이미지 크기에 따라 성능차이가 발생
- 같은 크기라도 이미지가 복잡 할 수록 성능차이가 발생
- 참고사이트:
    - https://diyver.tistory.com/98   색상 판별
    - https://diyver.tistory.com/97   관심 영역 설정(ROI )
    - https://diyver.tistory.com/102  houghcircle 설정

핵심코드
```c
HoughCircles(img_houghC, circles, HOUGH_GRADIENT, 1, 100, 50, 35, 0, 0); 
//(입력이미지, 출력이미지, method ,dp , 원중심간 거리, parm1,parm2 ,원최대크기, 원최소크기)
```
param2가 가장 예민하게 반응하는값으로 0~100 사이의 값을 넣는다. 값이 커지면 커질 수록 둔해지고 작으면 예민해진다.


> 예시 코드
```C
#include <opencv2/opencv.hpp>

using namespace cv;
using namespace std;

void video_test() {
	
	VideoCapture cap("Sub_project.mp4",0);
	//cap.set(CV_CAP_PROP_FRAME_WIDTH, 1920);
	//cap.set(CV_CAP_PROP_FRAME_HEIGHT, 1080);


	if (!cap.isOpened())
	{
		printf("Can't open the camera");
		return ;
	}

	Mat img;
	Mat hsv;
	Mat img_tmp;
	//Mat img_houghC;
	//vector<Vec3f> circles;
	//cap >> img;
	//cvtColor(img, img_tmp, COLOR_BGR2GRAY);
	//img_tmp.copyTo(img_houghC);
	//HoughCircles(img_houghC, circles, HOUGH_GRADIENT, 1, 100, 50, 35, 0, 0);
	//for (size_t i = 0; i < circles.size(); i++)
	//{
	//	Vec3i c = circles[i];
	//	Point center(c[0], c[1]);
	//	int radius = c[2];

	//	circle(img_houghC, center, radius, Scalar(0, 255, 0), 2);
	//	circle(img_houghC, center, 2, Scalar(0, 0, 255), 3);
	//}

	while (1)
	{
		cap >> img;
		cvtColor(img, hsv, COLOR_RGB2HSV);
		cvtColor(img, img_tmp, COLOR_BGR2GRAY);

		//medianBlur(img, img_tmp, 5);
		//img_tmp.copyTo(img_houghC);
		//HoughCircles(img_houghC, circles, HOUGH_GRADIENT, 1, 100, 50, 35, 0, 0);

		//for (size_t i = 0; i < circles.size(); i++)
		//{
		//	Vec3i c = circles[i];
		//	Point center(c[0], c[1]);
		//	int radius = c[2];

		//	circle(img_houghC, center, radius, Scalar(0, 255, 0), 2);
		//	circle(img_houghC, center, 2, Scalar(0, 0, 255), 3);
		//}

		if (img.empty())
		{
			printf("empty image");
			return;
		}

		imshow("camera img", img);
		imshow("camera hsv", hsv);
		imshow("camera tmp", img_tmp);

		//imshow("img_houghC", img_houghC);

		if (waitKey(25) == 27)
			break;
	}


	//return 0;
}


void img_test()
{

	VideoCapture cap("Sub_project.mp4", 0);
	Mat img;
	Mat img_houghC;
	Mat img2;
	vector<Vec3f> circles;

	Mat input;
	Mat input1;
	Mat edge;
	vector<Vec2f> lines;

	// hough 변환 필요해 보임.
	while (1) {
		cap >> img;
		if (img.empty()) return;
		cvtColor(img, img2, COLOR_RGB2GRAY);
		//resize(img, img, Size(100, 100));   //크기가 작아질수록 성능이 상승 
		cvtColor(img, img, COLOR_RGB2GRAY);
		//=========================================hough 변환 
		GaussianBlur(img2, input1, Size(), (double)1);
		Canny(input1, edge, 50, 150);
		HoughLines(edge, lines, 1, CV_PI / 180, 250);
		//===================================================

		medianBlur(img, img, 5);
		//img.copyTo(img_houghC);
		//edge.copyTo(img_houghC);
		img.copyTo(img_houghC);
		//resize(img_houghC, img_houghC, Size(150, 150));


		HoughCircles(img_houghC, circles, HOUGH_GRADIENT, 1, 20, 50, 25, 0, 0);

		for (size_t i = 0; i < circles.size(); i++)
		{
			Vec3i c = circles[i];
			Point center(c[0], c[1]);
			int radius = c[2];

			circle(img_houghC, center, radius, Scalar(0, 255, 0), 2);
			circle(img_houghC, center, 2, Scalar(0, 0, 255), 3);
		}


		imshow("img_houghC", img_houghC);
		imshow("hough", edge);

		//imshow("img2", img2);

		if (waitKey(25) == 27) break;
		//waitKey(0); // 키를 눌러야지 다음 사진으로 넘어감 
	}
	//return 0;
}


int main(int ac, char** av) {
	
	img_test();
	//video_test();
	return 0;
}
```