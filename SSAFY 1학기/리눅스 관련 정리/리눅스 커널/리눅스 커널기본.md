# 리눅스 커널 기본
// 22.05.11 업데이트

- 일단 커널 만들기는 무지하게 어렵다. 
- 교안을 최대한 참고하자
- 아래 내용을 내가 이해한 내용을 바탕으로 제작 했다.

> 커널 업데이트를 왜 할까?
- 커널 업데이트 과정에서 얻어지는 디바이스 드라이버 개발을 하기 위해서 사용한다. (즉 학습을 위해)
- 먼저 디바이스 드라이버에 관해 알아야한다.
- 그럼 드라이버는 왜 사용하는가? 
  - 프로그램이 HW를 제어하기 위한 SW (한문장으로 설명은 어려움)
  - 즉 HW의 메모리적 접근을 하는 느낌? 

> firmware 에서 임베디드 개발
- 펌웨어에서는 app이 HW를 직접 제어한다.  
- application(app)이라 한다 
- 사용자가 건드릴수 있는 프로그램에서 메모리를 건드릴 수 있냐 없냐
-  펌웨어 level과 리눅스 level은 다르다 

> 리눅스에서 개발
- 리눅스에서는 app level에서 메모리를 절대로 건들이지 못하게 한다.
  - 예를들어 LED on 이라는 함수를 app에서 만들었어도 직접적으로 하드웨어 에서<br> 접근을 하지 못한다.
- 이걸 커널을 이용해서 할거다. <br>아래그림을 참고

![캡처](/img/%EC%BB%A4%EB%84%902.jpg)

- <span style="color:orange">각각의 연결고리를 잘 파악해보자</span>

> 환경 세팅
- 주의 사항
  - Boot시 GUI 환경으로 나오는 것을 CLI로 변경(최대한 CPU의 부하를 줄이기 위함)
    - 단 나의 경우 CLI변경후 다시 GUI로 돌아오니 설정이 모두 초기화 되어있었고 <br> GUI 환경에서 딜레이가 굉장히 심하게 생김. 특히 VNC를 이용한경우 사용을 못한 정도
    - 해결방법은 탐색중
- 준비 단계
  - ip scaner를 이용하여 mobaxterm에 연결
  - $sudo apt-get update
  - $sudo apt-get upgrade
  - $sudo apt install terminator //터미네이터
  - $sudo apt install vim //vim
- 커널 업데이트<span style="color:orange">(시간 약 1시간 소요)</span>
  - $sudo apt install git bc bison flex libssl-dev make
  - $cd /usr/src
  - $sudo git clone --depth=1 https://github.com/raspberrypi/linux
  - $cd linux
  - $KERNEL=kernel7l
  -   $sudo make bcm2711_defconfig
  -   $sudo make -j4 zImage modules dtbs
  -   $sudo make modules_install
  -   $sudo cp arch/arm/boot/dts/.dtb /boot/
  -   $sudo cp arch/arm/boot/dts/overlays/.dtb* /boot/overlays/
  -   $sudo cp arch/arm/boot/dts/overlays/README /boot/overlays/
  -   $ sudo cp arch/arm/boot/zImage /boot/$KERNEL.img

- 버전 확인
  - $uname -r
  -   sudo reboot
  -   $uname -r : 버전 확인 
    - 현재 나의 버전은 <span style="color:orange">"5.15.36-v7l+"</span> 이다

> 커널 프로그래밍 시작
 
- 먼저 커널을 구동하기 위해서는
커널 생성 C 파일과  이를 실행하기 위한 makefile이 필요하다.
  - 참고! 라즈베리파이를 처음 CLI 환경으로 연결한경우 아래 것들이 설치가 안되어 있을 수 도 있다.
    - vim 에디터 //설치후 vi ~/.vimrc를 이용 자신이 원하는 환경 세팅
    - make 설치  // makefile실행시 필요
    - gcc 설치     // C, C++컴파일시 필요
<br>
<br>

- $ dmesg -w 커널로그 켜기(커널이 잘 작동하는지 알 수 있다.)
- km.c , makefile 두개를 한폴더 안에 만들자.

## Makefile
```C
KERNEL_SRC=/usr/src/linux  // KERNEL_HEADERS=/lib/modules/$(shell uname -r)/build 

obj-m := km.o  

go:
    make -C $(KERNEL_SRC) M=$(PWD) modules
clean:
    make -C $(KERNEL_SRC) M=$(PWD) clean
```
- KERNEL_SRC=/usr/src/linux 대신
- KERNEL_HEADERS=/lib/modules/$(shell uname -r)/build 를 대신 사용해도된다.
- 경로 또는 파일 이름으로 설정해도 되기 때문
- obj-m := km.o는 주의!!! 
- 주의!!! 이름을 자신이 만든 커널C 파일로 해야한다. 나의 경우 km.o

## km.c   // 그냥 햄버거 가게 이름(다른이름으로 해도됨) 
- 참고: 파일명은 자신이 원하는 것으로 해도됨 하지만 makefile 의 파일 명도 도일하게 설정할 것(나중에 알아보기 쉽게 너무 막 만짓지 말자)
```C
#include <linux/module.h>
#include <linux/fs.h>

#define NOD_NAME "km"
#define NOD_MAJOR 100

MODULE_LICENSE("GPL");

//커널이 시작 될때 dmseg 하면 출력
static int km_open(struct inode *inode, struct file *filp) {
    printk( KERN_INFO "OPEN!!!\n");
    return 0;
}

//커널을 끄면 출력
static int km_release(struct inode *inode, struct file *filp) {
    printk( KERN_INFO "CLOSE!!!\n");
    return 0;
}


static struct file_operations fops = {
    .open = km_open,
    .release = km_release
};

static int km_init(void) {
    printk( KERN_INFO "OK HELLO km!!\n");
    if (register_chrdev(NOD_MAJOR, NOD_NAME, &fops) < 0) {
        printk( KERN_INFO "ERROR!!! register error\n");
    }

    return 0;
}

static void km_exit(void) {
    unregister_chrdev(NOD_MAJOR, NOD_NAME);
    printk( KERN_INFO "BYE BYE\n\n");
}



module_init(km_init);
module_exit(km_exit);
```


- sudo insmod hi.ko :커널 적재 // 이름은 알맞게 변경
- sudo rmmod hi : 커널에 모듈 제거